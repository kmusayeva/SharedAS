% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sharedAS.R
\name{SharedAS}
\alias{SharedAS}
\title{Computes shared active subspace for vector-valued functions.}
\usage{
SharedAS(
  fn,
  grads = NULL,
  X = NULL,
  distr = list(name = "norm", n = 1000),
  input_dim,
  num_obj,
  start_dim = NULL,
  end_dim = NULL,
  methods = NULL,
  nexps = 1,
  is_norm = TRUE,
  seed = 126,
  params = NULL
)
}
\arguments{
\item{fn}{Vector-valued function for which to compute a shared active subspace}

\item{grads}{Optional, matrix of objective-wise gradients concatenated together}

\item{X}{Matrix of input data: to provide only if \code{grads} are provided}

\item{distr}{List indicating the data distribution and its parameters:
\itemize{
\item \code{name} either "unif" for the uniform or "norm" for a normal (default is the standard normal) distribution
\item \code{n} number of samples
\item \code{sigma} covariance matrix, if the distribution is set to "norm" (the mean is always zero)
 }}

\item{input_dim}{Dimensionality of the input data}

\item{num_obj}{Number of outputs of the test function}

\item{start_dim}{Optional, start number of the dominating eigenvectors}

\item{end_dim}{End number of the dominating eigenvectors: To be set if \code{start_dim} is set.}

\item{methods}{Vector of method names to compute a shared subspace
\itemize{
\item AG: average of gradients
\item LP: linear projection of gradients
\item MCH: minimum convex hull of gradients
\item SEE: stepwise estimation of eigenvectors
\item SSPD: sum of SPD matrices
\item FG: joint diagonalization of SPD matrices
\item Zahm: the method of Zahm
}}

\item{nexps}{Number of experiments}

\item{is_norm}{Logical, indicates whether to normalize the function outputs in the gradient computation (default is TRUE)}

\item{seed}{Random seed for reproducibility}

\item{params}{List of additional parameters for the test function}
}
\value{
List of objective-wise root-mean-square error and its sum for each number of dimensions and for each method, over \code{nexps} number of experiments
}
\description{
Computes shared active subspace for vector-valued functions.
}
\details{
Depending on the problem, the method of MCH can be costly to compute.
}
\examples{

fn <- problem_car_side_impact
input_dim <- 7
num_obj <- 11
nexps <- 5
# distr <- list(name="unif", n=10)
distr <- list(name = "norm", n = 1000)
SharedAS(
  fn = fn, distr = distr, input_dim = input_dim, num_obj = num_obj,
  methods = c("AG", "LP", "MCH", "SSPD", "SEE", "FG", "Zahm"),
  nexps = nexps, is_norm = TRUE, seed = 126, params = NULL
)


fn <- problem_marinedes
input_dim <- 6
num_obj <- 3
nexps <- 1
distr <- list(name = "norm", n = 1000)
SharedAS(
  fn = fn, distr = distr, input_dim = input_dim, num_obj = num_obj,
  methods = c("AG", "LP", "MCH", "SSPD", "SEE", "FG", "Zahm"),
  nexps = nexps, is_norm = TRUE, seed = 126, params = NULL
)


fn <- problem_penicillin
input_dim <- 7
num_obj <- 5
nexps <- 1
distr <- list(name = "norm", n = 1000)
params <- list(t = 100, returnCST = TRUE)
SharedAS(
  fn = fn, distr = distr, input_dim = input_dim, num_obj = num_obj,
  methods = c("AG", "LP", "MCH", "SSPD", "SEE", "FG", "Zahm"), nexps = nexps,
  is_norm = TRUE, seed = 126, params = params
)


fn <- problem_switch_ripple
input_dim <- 8
num_obj <- 5 # if returCST=TRUE, then numb_obj=10
distr <- list(name = "norm", n = 1000)
nexps <- 1
params <- list(returnCST = FALSE)
SharedAS(
  fn = fn, distr = distr, input_dim = input_dim, num_obj = num_obj,
  methods = c("AG", "LP", "MCH", "SSPD", "SEE", "FG", "Zahm"), nexps = nexps,
  is_norm = TRUE, seed = 126, params = params
)


fn <- problem_synthetic
input_dim <- 3
num_obj <- 2
nexps <- 30
distr <- list(name = "unif", n = 1000)
SharedAS(
  fn = fn, distr = distr, input_dim = input_dim, num_obj = num_obj,
  methods = c("AG", "LP", "MCH", "SSPD", "SEE", "FG", "Zahm"), nexps = nexps,
  is_norm = TRUE, seed = 126
)

}
