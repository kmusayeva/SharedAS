% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods_grad.R
\name{methods_grad}
\alias{methods_grad}
\title{Computes representative vectors for the Jacobians evaluated at data points and returns the matrix of eigenvectors obtained from the SPD matrix build from such vectors.}
\usage{
methods_grad(
  grads,
  n,
  m,
  d,
  method = c("AG", "LP", "MCH"),
  is_grad_norm = FALSE
)
}
\arguments{
\item{grads}{Gradient matrix, where the columns are the concatenation of the objective-wise gradients}

\item{n}{Sample size}

\item{m}{Number of objectives or function outputs}

\item{d}{Number of input dimensions}

\item{method}{The method to compute a reprentative vector, either
\itemize{
\item 'AG' computes the average of gradient vectors
\item 'LP'  for each input variable, computes the rank-1 linear projection of the objective-wise derivatives wrt that variable
(based on the leading eigenvector of the SPD matrix of these same derivatives).

\item 'MCH' computes the minimum-norm element of the convex hull computed from the Jacobian
}}

\item{is_grad_norm}{If set to \code{TRUE}, performs the L2 normalization of the gradients. This is used only for AG and MCH.}
}
\value{
Matrix of eigenvectors (column vectors)
}
\description{
Computes representative vectors for the Jacobians evaluated at data points and returns the matrix of eigenvectors obtained from the SPD matrix build from such vectors.
}
\examples{
fn <- problem_car_side_impact
d <- 7
n <- 1000
X <- matrix(runif(d * n), n)
Y <- t(apply(X, 1, fn))
grads <- t(apply(X, 1, function(x) c(t(numDeriv::jacobian(fn, x = x)))))
methods_grad(grads, n, ncol(Y), d, method = "MCH")

}
