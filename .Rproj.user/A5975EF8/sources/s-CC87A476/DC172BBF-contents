#' Computes shared active subspace for vector-valued functions.
#'
#' @param fn Vector-valued function for which to compute shared active subspace
#' @param num_samples Number of samples to be generated
#' @param input_dim Dimensionality of the input data
#' @param num_obj Number of outputs of the test function
#' @param methods Set of methods to use for analysis (choices: {"AG", "LP", "MCH", "SEE", "FG", "Zahm"})
#' @param nexps Number of experiments to conduct
#' @param grads User-provided gradients
#' @param distr Data distribution to use ("unif" for uniform or "norm" for normal; default is the standard normal)
#' @param is_norm Indicates whether to normalize the function outputs in gradient computation (logical)
#' @param verbose If \code{TRUE}, prints out the analysis results
#' @param seed Random seed for reproducibility
#' @param ... Additional parameters for the test function (to be specified in a list named \code{params})
#'
#' @return List of objective-wise root-mean-square error and its total for each number of dimensions and for each method, over \code{nexps} experiments
#' @export
#'
#' @examples
#'
#' fn <- switch_ripple_n
#' num_samples <- 1000
#' distr <- "unif"
#' input_dim <- 8
#' num_obj <- 5
#' nexps <- 10
#' params=list(constraints = FALSE)
#' Result <- SharedAS(fn, num_samples, distr, input_dim, num_obj, methods=c("AG", "LP", "MCH", "SSPD", "SEE", "FG"), nexps, params=params, is_norm=TRUE)
#'
#'
#' fn <- penicillin
#' num_samples <- 1000
#' distr <- "norm"
#' input_dim <- 7
#' num_obj <- 5
#' nexps <- 10
#' params <- list(t=100, constraints=TRUE)
#' Result <- SharedAS(fn, num_samples, distr, input_dim, num_obj, methods=c("AG", "LP", "MCH", "SSPD", "SEE", "FG", "Zahm"), nexps, params=params)
#'
#'
#' fn <- Ptest
#' num_samples <- 1000
#' distr <- "unif"
#' input_dim <- 3
#' num_obj <- 2
#' nexps <- 1
#' params <- NULL
#' Result <- SharedAS(fn, num_samples, distr, input_dim, num_obj, methods=c("AG", "LP", "MCH", "SSPD", "SEE", "FG"), nexps)
#'
#'
#' fn <- carpb
#' num_samples <- 1000
#' distr <- "unif"
#' input_dim <- 7
#' num_obj <- 11
#' nexps <- 1
#' Result_norm <- SharedAS(fn, num_samples, distr, input_dim, num_obj, methods=c("AG", "LP", "MCH", "SSPD", "SEE", "FG"), nexps, is_norm=FALSE)
#'
#'
#' fn <- marinedes
#' num_samples <- 1000
#' distr <- "unif"
#' input_dim <- 6
#' num_obj <- 3
#' nexps <- 10
#' Result <- SharedAS(fn, num_samples, distr, input_dim, num_obj, methods=c("AG", "LP", "SSPD", "SEE", "FG"), nexps)
#'
SharedAS <- function(fn, grads=NULL, num_samples, distr="norm", input_dim, num_obj, methods=NULL, nexps, is_norm=TRUE, verbose=TRUE, seed = 126, ...) {

  all_methods <- c("AG", "LP", "MCH", "SSPD", "SEE", "FG", "Zahm")

  if(is.null(methods))  {methods <- all_methods}
  else if(sum(!methods %in% all_methods)) {stop(cat("Possible choices:", all_methods,"\n"))}

  # if(distr=="unif") cat("The method of Zahm applies to the normal distribution.\n")

  if (!distr %in% c("norm","unif")) stop("Possible choice for distribution: norm or unif.")
  if (is.null(num_samples)) stop("Please specify the number of samples.")
  if (is.null(input_dim)) stop("Please specify the number of dimensions.")
  if (is.null(num_obj)) stop("Please specify the number of objectives.")
  if (is.null(nexps)) stop("Please specify the number of experiments.")


  d <- input_dim
  m <- num_obj

  Result <- createResultMatrix(d, m, nexps, methods)

  set.seed(seed)

  for(i in 1:nexps) {

    n <- num_samples

    X <- if(distr=="unif") matrix(runif(d*n, min = -1, max = 1), n) else rmvnorm(n=n, mean=rep(0,d), sigma=diag(1, d))

    Y <- wrapper(X, fn, distr, NULL, ...)

    m <- ncol(Y) #update number of objs if some params are used as objs

    if(!is.null(params$t)) { #penicillin problem
          ind <- which(Y[,1]==params$t)
          Y <- Y[ind,]
          X <- X[ind,]
          n <- nrow(X)
          m <- ncol(Y)-1
          }


    ###get mean and std of the function outputs for the mean-variance normalization
    Y_mean <- colMeans(Y); Y_std <- apply(Y, 2, sd); Y_norm <- mean_var_norm(Y, Y_mean, Y_std); norm=list("mean"=Y_mean, "std"=Y_std)


    ###if the gradients are not given, compute them
    if(is.null(grads))  {

      cat("Sample: ", i, " \n computing gradients...")

      grads <- if(is_norm) compute_grad(X, fn, distr, norm, ...) else compute_grad(X, fn, distr, NULL, ...) #computes the grads

      cat(" done \n")

          }

    if(!is.null(params$t)) {grads <- grads[,-c(1:d)]} # for the penicillin problem, need to be optimized

    ###the method of Zahm
    if(length(Result$Zahm)) {

        ###should not be used with uniform
        if(distr=="unif") {

          cat("The method of Zahm applies only to the normal distribution")

          Xprime <- rmvnorm(n=n, mean=rep(0,d), sigma=diag(1, d))

          } else  Xprime <- X


        res_zahm <- Zahm(Xprime, n, m, d, fn, grads,  norm=list(mean=Y_mean, std=Y_std), number_sample=20, seed=16, ...)

        }


    evectors <- list() #contains eigenvectors

    for(method in methods) { #iterate through the given list of methods and compute the eigendecomposition

      evectors[[method]] <- switch(

        method,

        "SSPD" = SPD_level(grads, n, m, d, method = "SSPD"),

        "SEE" = SPD_level(grads, n, m, d, method = "SEE"),

        "FG" = SPD_level(grads, n, m, d, method = "FG"),

        "AG" = grad_level(grads, n, m, d, method = "AG"),

        "MCH" = grad_level(grads, n, m, d, method = "MCH"),

        "LP" = grad_level(grads, n, m, d, method = "LP")

        )

      }

    cat(" computing active subspace... ")

    for(num_dim in 1:d) {

      if(length(evectors)) {

          for(ei in 1:length(evectors)) {

              res <- project_data(evectors[[ei]], num_dim, X, fn, distr, norm=list(mean=Y_mean, std=Y_std),...) #given the eigenvectors, reconstruct the data

              rmses <-rmse_wrapper(Y_norm, res$Yest,...)

              Result[[names(evectors[ei])]][[num_dim]][i,] <- rmses

                       }
                  }

        if(length(Result$Zahm)) {

          rmses <- rmse_wrapper(Y_norm, res_zahm[[num_dim]], ...)

          Result$Zahm[[num_dim]][i,] <- rmses

                }

           }

       if(verbose) print(Result)

   cat("done\n")

        }


  return(Result)

  }



